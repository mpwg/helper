#!/bin/bash

set -euo pipefail

VERSION="1.0.0"
SCRIPT_NAME="github-secrets-import"

show_help() {
    cat << EOF
GitHub Secrets Import Tool v${VERSION}

DESCRIPTION:
    Reads variables from a .env file and imports them as GitHub repository secrets.
    Validates the import process and offers options for handling existing secrets.

USAGE:
    ${SCRIPT_NAME} [OPTIONS] <.env-file> <owner/repo>

ARGUMENTS:
    .env-file       Path to the .env file containing variables to import
    owner/repo      GitHub repository in format owner/repository

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version information
    -t, --token     GitHub token (or set GITHUB_TOKEN environment variable)
    -f, --force     Overwrite existing secrets without prompting
    -s, --skip      Skip existing secrets without prompting
    -d, --dry-run   Show what would be imported without making changes

EXAMPLES:
    ${SCRIPT_NAME} .env myuser/myrepo
    ${SCRIPT_NAME} -t ghp_token123 .env myuser/myrepo
    ${SCRIPT_NAME} --dry-run .env myuser/myrepo
    ${SCRIPT_NAME} --force .env myuser/myrepo

REQUIREMENTS:
    - curl (for GitHub API calls)
    - jq (for JSON processing)
    - GitHub token with repo permissions

EOF
}

show_version() {
    echo "${SCRIPT_NAME} v${VERSION}"
}

log_info() {
    echo "[INFO] $1" >&2
}

log_warn() {
    echo "[WARN] $1" >&2
}

log_error() {
    echo "[ERROR] $1" >&2
}

log_success() {
    echo "[SUCCESS] $1" >&2
}

check_dependencies() {
    local missing_deps=()

    if ! command -v curl &> /dev/null; then
        missing_deps+=("curl")
    fi

    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        log_error "Please install the missing dependencies and try again."
        exit 1
    fi
}

validate_env_file() {
    local env_file="$1"

    if [ ! -f "$env_file" ]; then
        log_error "Environment file does not exist: $env_file"
        exit 1
    fi

    if [ ! -r "$env_file" ]; then
        log_error "Cannot read environment file: $env_file"
        exit 1
    fi

    if [ ! -s "$env_file" ]; then
        log_warn "Environment file is empty: $env_file"
        return 1
    fi

    return 0
}

parse_env_file() {
    local env_file="$1"
    local temp_file
    temp_file=$(mktemp)

    # Parse .env file, ignoring comments and empty lines
    # Handle quoted values and escape sequences
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
            continue
        fi

        # Check for valid variable assignment
        if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$ ]]; then
            local var_name="${BASH_REMATCH[1]}"
            local var_value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present
            if [[ "$var_value" =~ ^\"(.*)\"$ ]] || [[ "$var_value" =~ ^\'(.*)\'$ ]]; then
                var_value="${BASH_REMATCH[1]}"
            fi

            echo "$var_name=$var_value" >> "$temp_file"
        else
            log_warn "Skipping invalid line: $line"
        fi
    done < "$env_file"

    echo "$temp_file"
}

validate_github_token() {
    local token="$1"

    if [ -z "$token" ]; then
        log_error "GitHub token is required. Set GITHUB_TOKEN environment variable or use -t option."
        exit 1
    fi

    # Validate token format (basic check)
    if [[ ! "$token" =~ ^(ghp_|gho_|ghu_|ghs_|ghr_) ]]; then
        log_warn "GitHub token format may be invalid (should start with ghp_, gho_, ghu_, ghs_, or ghr_)"
    fi

    # Test token by making a simple API call
    local response
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: token $token" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/user")

    if [ "$response" != "200" ]; then
        log_error "Invalid GitHub token or insufficient permissions (HTTP $response)"
        exit 1
    fi
}

validate_repository() {
    local repo="$1"
    local token="$2"

    if [[ ! "$repo" =~ ^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$ ]]; then
        log_error "Invalid repository format. Expected: owner/repository"
        exit 1
    fi

    # Check if repository exists and is accessible
    local response
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: token $token" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/$repo")

    case "$response" in
        200)
            log_info "Repository access validated: $repo"
            ;;
        404)
            log_error "Repository not found or no access: $repo"
            exit 1
            ;;
        *)
            log_error "Failed to validate repository access (HTTP $response): $repo"
            exit 1
            ;;
    esac
}

get_repository_public_key() {
    local repo="$1"
    local token="$2"

    local response
    response=$(curl -s \
        -H "Authorization: token $token" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/$repo/actions/secrets/public-key")

    if [ $? -ne 0 ] || [ -z "$response" ]; then
        log_error "Failed to get repository public key"
        exit 1
    fi

    echo "$response"
}

get_existing_secrets() {
    local repo="$1"
    local token="$2"

    local response
    response=$(curl -s \
        -H "Authorization: token $token" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/$repo/actions/secrets")

    if [ $? -ne 0 ] || [ -z "$response" ]; then
        log_error "Failed to get existing secrets"
        exit 1
    fi

    echo "$response" | jq -r '.secrets[].name' 2>/dev/null || echo ""
}

encrypt_secret() {
    local value="$1"
    local public_key="$2"

    # Use Python for encryption since it's available on most systems
    python3 -c "
import base64
import sys
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.backends import default_backend

try:
    public_key = serialization.load_pem_public_key(
        base64.b64decode('$public_key').decode('utf-8').encode(),
        backend=default_backend()
    )

    encrypted = public_key.encrypt(
        '$value'.encode('utf-8'),
        padding.PKCS1v15()
    )

    print(base64.b64encode(encrypted).decode('utf-8'))
except ImportError:
    print('ENCRYPTION_NOT_AVAILABLE', file=sys.stderr)
    sys.exit(1)
except Exception as e:
    print(f'ENCRYPTION_ERROR: {e}', file=sys.stderr)
    sys.exit(1)
" 2>/dev/null
}

encrypt_secret_fallback() {
    local value="$1"
    local public_key="$2"

    # Fallback using openssl and base64 (less secure but widely available)
    log_warn "Using fallback encryption method. Consider installing Python cryptography library for better security."

    echo -n "$value" | openssl rsautl -encrypt -pubin -inkey <(echo "$public_key" | base64 -d) | base64 -w 0
}

create_or_update_secret() {
    local repo="$1"
    local token="$2"
    local secret_name="$3"
    local encrypted_value="$4"
    local key_id="$5"
    local dry_run="$6"

    if [ "$dry_run" = "true" ]; then
        log_info "DRY RUN: Would create/update secret: $secret_name"
        return 0
    fi

    local payload
    payload=$(jq -n \
        --arg encrypted_value "$encrypted_value" \
        --arg key_id "$key_id" \
        '{encrypted_value: $encrypted_value, key_id: $key_id}')

    local response
    response=$(curl -s -o /dev/null -w "%{http_code}" \
        -X PUT \
        -H "Authorization: token $token" \
        -H "Accept: application/vnd.github.v3+json" \
        -H "Content-Type: application/json" \
        -d "$payload" \
        "https://api.github.com/repos/$repo/actions/secrets/$secret_name")

    if [ "$response" = "201" ] || [ "$response" = "204" ]; then
        log_success "Secret created/updated: $secret_name"
        return 0
    else
        log_error "Failed to create/update secret: $secret_name (HTTP $response)"
        return 1
    fi
}

prompt_user() {
    local message="$1"
    local default="$2"
    local response

    read -p "$message [$default]: " response
    echo "${response:-$default}"
}

main() {
    local env_file=""
    local repo=""
    local github_token="${GITHUB_TOKEN:-}"
    local force_overwrite=false
    local skip_existing=false
    local dry_run=false

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -t|--token)
                github_token="$2"
                shift 2
                ;;
            -f|--force)
                force_overwrite=true
                shift
                ;;
            -s|--skip)
                skip_existing=true
                shift
                ;;
            -d|--dry-run)
                dry_run=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Use --help for usage information."
                exit 1
                ;;
            *)
                if [ -z "$env_file" ]; then
                    env_file="$1"
                elif [ -z "$repo" ]; then
                    repo="$1"
                else
                    log_error "Too many arguments"
                    echo "Use --help for usage information."
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [ -z "$env_file" ] || [ -z "$repo" ]; then
        log_error "Missing required arguments"
        echo "Use --help for usage information."
        exit 1
    fi

    if [ "$force_overwrite" = true ] && [ "$skip_existing" = true ]; then
        log_error "Cannot use --force and --skip together"
        exit 1
    fi

    log_info "Starting GitHub secrets import process"

    # Check dependencies
    check_dependencies

    # Validate inputs
    validate_env_file "$env_file" || exit 1
    validate_github_token "$github_token"
    validate_repository "$repo" "$github_token"

    # Parse .env file
    log_info "Parsing environment file: $env_file"
    local parsed_env
    parsed_env=$(parse_env_file "$env_file")

    if [ ! -s "$parsed_env" ]; then
        log_error "No valid environment variables found in $env_file"
        rm -f "$parsed_env"
        exit 1
    fi

    local var_count
    var_count=$(wc -l < "$parsed_env")
    log_info "Found $var_count environment variables to import"

    # Get repository public key for encryption
    log_info "Getting repository public key for encryption"
    local public_key_info
    public_key_info=$(get_repository_public_key "$repo" "$github_token")
    local public_key
    public_key=$(echo "$public_key_info" | jq -r '.key')
    local key_id
    key_id=$(echo "$public_key_info" | jq -r '.key_id')

    # Get existing secrets
    log_info "Getting existing repository secrets"
    local existing_secrets
    existing_secrets=$(get_existing_secrets "$repo" "$github_token")

    # Process each environment variable
    local success_count=0
    local skip_count=0
    local error_count=0

    while IFS='=' read -r var_name var_value; do
        log_info "Processing variable: $var_name"

        # Check if secret already exists
        local secret_exists=false
        if echo "$existing_secrets" | grep -q "^$var_name$"; then
            secret_exists=true
        fi

        if [ "$secret_exists" = true ]; then
            local action=""

            if [ "$force_overwrite" = true ]; then
                action="overwrite"
            elif [ "$skip_existing" = true ]; then
                action="skip"
            else
                log_warn "Secret '$var_name' already exists"
                if [ "$dry_run" = false ]; then
                    action=$(prompt_user "Action for existing secret '$var_name' (overwrite/skip)" "skip")
                else
                    action="overwrite"
                fi
            fi

            case "$action" in
                overwrite|o)
                    log_info "Overwriting existing secret: $var_name"
                    ;;
                skip|s)
                    log_info "Skipping existing secret: $var_name"
                    ((skip_count++))
                    continue
                    ;;
                *)
                    log_warn "Invalid action '$action'. Skipping secret: $var_name"
                    ((skip_count++))
                    continue
                    ;;
            esac
        fi

        # Encrypt the secret value
        local encrypted_value
        encrypted_value=$(encrypt_secret "$var_value" "$public_key")

        if [ $? -ne 0 ] || [ -z "$encrypted_value" ]; then
            log_warn "Failed to encrypt using primary method, trying fallback"
            encrypted_value=$(encrypt_secret_fallback "$var_value" "$public_key")
        fi

        if [ $? -ne 0 ] || [ -z "$encrypted_value" ]; then
            log_error "Failed to encrypt secret: $var_name"
            ((error_count++))
            continue
        fi

        # Create or update the secret
        if create_or_update_secret "$repo" "$github_token" "$var_name" "$encrypted_value" "$key_id" "$dry_run"; then
            ((success_count++))
        else
            ((error_count++))
        fi

    done < "$parsed_env"

    # Cleanup
    rm -f "$parsed_env"

    # Summary
    log_info "Import process completed"
    log_info "Successfully processed: $success_count secrets"
    log_info "Skipped: $skip_count secrets"
    log_info "Errors: $error_count secrets"

    if [ "$dry_run" = true ]; then
        log_info "DRY RUN: No actual changes were made"
    fi

    if [ $error_count -gt 0 ]; then
        exit 1
    fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi